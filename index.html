<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Personal Website</title>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        header {
            background-color: rgba(88, 100, 29, 0.7);
            background-image: url("assets/Joshua Tree Photo 2023.JPG");
            background-size: cover;
            background-position: center;
            color: #231F20;
            padding: 1rem;
            text-align: center;
        }
        .hero {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 70vh;
            background-color: #F4F7F5;
            color: #231F20;
            text-align: center;
            overflow: hidden;
        }
        .hero h1 {
            font-size: 3rem;
            margin: 0;
            position: relative;
            z-index: 10;
        }
        .hero p {
            font-size: 1.2rem;
            margin: 0.5rem 0;
            position: relative;
            z-index: 10;
        }
        #particle-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .particle-button {
            position: absolute;
            padding: 0.8rem 1.5rem;
            font-size: 1rem;
            border: 0px solid white;
            border-radius: 50px;
            cursor: pointer;
            background-color: #BB4430;
            color: white;
            font-weight: bold;
            pointer-events: auto;
            transition: transform 0.1s;
            z-index: 5;
        }
        .particle-button:hover {
            transform: scale(1.1);
            background-color: #a03820;
        }
    </style>
</head>
<body>
    <header>
        <h1>Welcome to My Website</h1>
    </header>
    <div class="hero" id="hero">
        <canvas id="particle-canvas"></canvas>
        <button class="particle-button" id="particle-0">Photography</button>
        <button class="particle-button" id="particle-1">Rocketry</button>
        <button class="particle-button" id="particle-2">Robotics</button>
        <button class="particle-button" id="particle-3">Projects</button>
        <h1 id="hero-title">Hello, I'm Patrick Chou</h1>
        <img src="assets/lineArtPortrait.png" alt="Portrait" style="width: 150px; height: auto; position: relative; z-index: 10; margin-top: 1rem;">
    <script>
        function typewriterEffect(element, text, speed) {
        let i = 0;
        function type() {
            if (i < text.length) {
            element.textContent += text.charAt(i);
            i++;
            setTimeout(type, speed);
            }
        }
        type();
        }

        const heroTitleElement = document.getElementById('hero-title');
        const heroTitleText = "Hello, I'm Patrick Chou";
        heroTitleElement.textContent = ""; // Clear initial text
        typewriterEffect(heroTitleElement, heroTitleText, 150);
    </script>
    </div>

    <script>
        const canvas = document.getElementById('particle-canvas');
        const ctx = canvas.getContext('2d');
        const heroTitle = document.getElementById('hero-title');
        
        // Set canvas size
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Get text bounding boxes
        function getTextBounds() {
            const titleRect = heroTitle.getBoundingClientRect();
            const heroRect = document.getElementById('hero').getBoundingClientRect();
            const portraitImg = document.querySelector('.hero img');
            const portraitRect = portraitImg.getBoundingClientRect();
            
            return [
                {
                    x: titleRect.left - heroRect.left,
                    y: titleRect.top - heroRect.top,
                    width: titleRect.width,
                    height: titleRect.height
                },
                {
                    x: portraitRect.left - heroRect.left,
                    y: portraitRect.top - heroRect.top,
                    width: portraitRect.width,
                    height: portraitRect.height
                }
            ];
        }

        // Capsule collision detection helper
        function capsuleDistance(x1, y1, w1, h1, x2, y2, w2, h2) {
            // Treat capsules as rectangles with rounded ends
            // Calculate the distance between two capsule centers accounting for their shapes
            const r1 = h1 / 2; // radius of first capsule's rounded ends
            const r2 = h2 / 2; // radius of second capsule's rounded ends
            
            // Get the effective length of the straight section
            const len1 = w1 - h1;
            const len2 = w2 - h2;
            
            // Calculate center-to-center distance
            const dx = x2 - x1;
            const dy = y2 - y1;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Minimum distance for collision (sum of radii plus half-lengths)
            const minDist = r1 + r2;
            
            return { distance, minDist, dx, dy };
        }

        // Capsule-to-rectangle collision
        function capsuleRectCollision(cx, cy, width, height, rx, ry, rw, rh) {
            // Expand rectangle by capsule's radius for easier collision detection
            const radius = height / 2;
            const expandedRect = {
                x: rx - radius,
                y: ry - radius,
                width: rw + radius * 2,
                height: rh + radius * 2
            };
            
            // Find closest point on expanded rectangle to capsule center
            const closestX = Math.max(expandedRect.x, Math.min(cx, expandedRect.x + expandedRect.width));
            const closestY = Math.max(expandedRect.y, Math.min(cy, expandedRect.y + expandedRect.height));
            
            const dx = cx - closestX;
            const dy = cy - closestY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            return { collision: distance < radius, distance, dx, dy, radius };
        }

        // Particle class
        class Particle {
            constructor(index, label) {
                this.index = index;
                this.label = label;
                this.button = document.getElementById(`particle-${index}`);
                this.isHovered = false;
                this.savedVx = 0;
                this.savedVy = 0;
                
                let isValidPosition = false;
                
                // Wait for button to render to get accurate dimensions
                setTimeout(() => {
                    this.width = this.button.offsetWidth;
                    this.height = this.button.offsetHeight;
                }, 0);
                
                while (!isValidPosition) {
                    this.x = Math.random() * (canvas.width - 200) + 100;
                    this.y = Math.random() * (canvas.height - 100) + 50;

                    const textBounds = getTextBounds();
                    isValidPosition = textBounds.every(box => {
                        const closestX = Math.max(box.x, Math.min(this.x, box.x + box.width));
                        const closestY = Math.max(box.y, Math.min(this.y, box.y + box.height));
                        const dx = this.x - closestX;
                        const dy = this.y - closestY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance >= 80;
                    });
                }
                
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.color = '#BB4430';
                
                // Get actual button dimensions after a short delay
                setTimeout(() => {
                    this.width = this.button.offsetWidth;
                    this.height = this.button.offsetHeight;
                    this.updateButtonPosition();
                }, 10);
                
                // Add hover event listeners
                this.button.addEventListener('mouseenter', () => {
                    this.isHovered = true;
                    this.savedVx = this.vx;
                    this.savedVy = this.vy;
                    this.vx = 0;
                    this.vy = 0;
                });
                
                this.button.addEventListener('mouseleave', () => {
                    this.isHovered = false;
                    this.vx = this.savedVx;
                    this.vy = this.savedVy;
                });
            }

            updateButtonPosition() {
                if (!this.width || !this.height) return;
                this.button.style.left = `${this.x - this.width / 2}px`;
                this.button.style.top = `${this.y - this.height / 2}px`;
            }

            update(particles, textBounds) {
                if (!this.width || !this.height) return;
                
                // Update position (only if not hovered)
                if (!this.isHovered) {
                    this.x += this.vx;
                    this.y += this.vy;

                    // Bounce off walls (accounting for capsule shape)
                    const radius = this.height / 2;
                    const halfWidth = this.width / 2;
                    
                    if (this.x + halfWidth > canvas.width || this.x - halfWidth < 0) {
                        this.vx = -this.vx;
                        this.savedVx = this.vx; // Update saved velocity
                        this.x = Math.max(halfWidth, Math.min(canvas.width - halfWidth, this.x));
                    }
                    if (this.y + radius > canvas.height || this.y - radius < 0) {
                        this.vy = -this.vy;
                        this.savedVy = this.vy; // Update saved velocity
                        this.y = Math.max(radius, Math.min(canvas.height - radius, this.y));
                    }

                    // Collide with other particles (capsule-to-capsule)
                    particles.forEach(other => {
                        if (other === this || !other.width || !other.height) return;
                        
                        const result = capsuleDistance(
                            this.x, this.y, this.width, this.height,
                            other.x, other.y, other.width, other.height
                        );
                        
                        if (result.distance < result.minDist) {
                            // Calculate collision response
                            const angle = Math.atan2(result.dy, result.dx);
                            
                            // Separate particles
                            const overlap = result.minDist - result.distance;
                            
                            if (!this.isHovered) {
                                this.x -= Math.cos(angle) * overlap / 2;
                                this.y -= Math.sin(angle) * overlap / 2;
                            }
                            if (!other.isHovered) {
                                other.x += Math.cos(angle) * overlap / 2;
                                other.y += Math.sin(angle) * overlap / 2;
                            }
                            
                            // Exchange velocities (elastic collision) - only for non-hovered particles
                            if (!this.isHovered && !other.isHovered) {
                                const tempVx = this.vx;
                                const tempVy = this.vy;
                                this.vx = other.vx;
                                this.vy = other.vy;
                                other.vx = tempVx;
                                other.vy = tempVy;
                                
                                // Update saved velocities
                                this.savedVx = this.vx;
                                this.savedVy = this.vy;
                                other.savedVx = other.vx;
                                other.savedVy = other.vy;
                            } else if (!this.isHovered) {
                                // If only this particle is moving, reflect it
                                this.vx = -this.vx;
                                this.vy = -this.vy;
                                this.savedVx = this.vx;
                                this.savedVy = this.vy;
                            } else if (!other.isHovered) {
                                // If only the other particle is moving, reflect it
                                other.vx = -other.vx;
                                other.vy = -other.vy;
                                other.savedVx = other.vx;
                                other.savedVy = other.vy;
                            }
                        }
                    });

                    // Collide with text boxes (capsule-to-rectangle)
                    textBounds.forEach(box => {
                        const result = capsuleRectCollision(
                            this.x, this.y, this.width, this.height,
                            box.x, box.y, box.width, box.height
                        );
                        
                        if (result.collision) {
                            if (result.distance === 0) {
                                // Inside the box, push out randomly
                                this.vx = -this.vx;
                                this.vy = -this.vy;
                                this.x += (Math.random() - 0.5) * 20;
                                this.y += (Math.random() - 0.5) * 20;
                                this.savedVx = this.vx;
                                this.savedVy = this.vy;
                            } else {
                                // Normalize collision vector
                                const nx = result.dx / result.distance;
                                const ny = result.dy / result.distance;
                                
                                // Push particle out
                                const overlap = result.radius - result.distance;
                                this.x += nx * overlap;
                                this.y += ny * overlap;
                                
                                // Reflect velocity
                                const dotProduct = this.vx * nx + this.vy * ny;
                                this.vx -= 2 * dotProduct * nx;
                                this.vy -= 2 * dotProduct * ny;
                                this.savedVx = this.vx;
                                this.savedVy = this.vy;
                            }
                        }
                    });
                }

                this.updateButtonPosition();
            }
        }

        // Create particles with labels
        const labels = ['Photography', 'Rocketry', 'Robotics', 'Projects'];
        const particles = [];
        for (let i = 0; i < 4; i++) {
            particles.push(new Particle(i, labels[i]));
        }

        // Animation loop
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const textBounds = getTextBounds();
            
            particles.forEach(particle => {
                particle.update(particles, textBounds);
            });

            requestAnimationFrame(animate);
        }

        animate();

        // Add click handlers
        document.querySelectorAll('.particle-button').forEach((button, index) => {
            button.addEventListener('click', () => {
                alert(`You clicked ${labels[index]}!`);
                // Add your navigation logic here
            });
        });
    </script>
</body>
</html>
