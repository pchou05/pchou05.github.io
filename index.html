<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Personal Website</title>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        header {
            background-color: #58641D;
            color: white;
            padding: 1rem;
            text-align: left;
        }
        .hero {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 70vh;
            background-color: #F4F7F5;
            color: #231F20;
            text-align: center;
            overflow: hidden;
        }
        .hero h1 {
            font-size: 3rem;
            margin: 0;
            position: relative;
            z-index: 10;
        }
        .hero p {
            font-size: 1.2rem;
            margin: 0.5rem 0;
            position: relative;
            z-index: 10;
        }
        #particle-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .particle-button {
            position: absolute;
            padding: 0.8rem 1.5rem;
            font-size: 1rem;
            border: 0px solid white;
            border-radius: 50px;
            cursor: pointer;
            background-color: #BB4430;
            color: white;
            font-weight: bold;
            pointer-events: auto;
            transition: transform 0.1s;
            z-index: 5;
        }
        .particle-button:hover {
            transform: scale(1.1);
            background-color: #a03820;
        }
        .portrait-container {
            position: relative;
            width: 240px;
            height: 240px;
            z-index: 10;
            margin-top: 1rem;
            cursor: crosshair;
            overflow: hidden;
            border-radius: 5px;
        }
        .portrait-base {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }
        .portrait-reveal-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #reveal-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <header>
        <h1>Welcome to My Website</h1>
    </header>
    <div class="hero" id="hero">
        <canvas id="particle-canvas"></canvas>
        <button class="particle-button" id="particle-0">Photography</button>
        <button class="particle-button" id="particle-1">Rocketry</button>
        <button class="particle-button" id="particle-2">Robotics</button>
        <button class="particle-button" id="particle-3">Projects</button>
        <h1 id="hero-title"></h1>
        <div class="portrait-container" id="portrait-container">
            <img src="assets/lineArtPortrait.png" alt="Portrait Base" class="portrait-base">
            <div class="portrait-reveal-layer">
                <canvas id="reveal-canvas"></canvas>
            </div>
        </div>
    </div>

    <section id="about" style="padding: 4rem 2rem; background-color: white; max-width: 1200px; margin: 0 auto;">
        <h2 style="font-size: 2.5rem; color: #4F5D2F; margin-bottom: 3rem; text-align: center;">About Me</h2>
        
        <div class="card-container">
            <!-- Card from left -->
            <div class="info-card slide-left" style="margin-bottom: 3rem;">
                <div style="flex: 1; min-width: 300px; padding: 2rem;">
                    <h3 style="color: #4F5D2F; font-size: 1.8rem; margin-bottom: 1rem;">Who I Am</h3>
                    <p style="font-size: 1.1rem; line-height: 1.8; color: #231F20;">
                        Hello! I'm Patrick Chou, I am also know as MoodyDonut64 across various online platforms. I love tinkering with hardware and taking photos in my free time!
                    </p>
                </div>
                
                </div>
            </div>

            <!-- Card from right -->
            <div class="info-card slide-right" style="margin-bottom: 3rem;">
                <div style="flex: 1; min-width: 300px; padding: 2rem;">
                    <h3 style="color: #4F5D2F; font-size: 1.8rem; margin-bottom: 1rem;">Designing</h3>
                    <p style="font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif system-ui;font-size: 1.1rem; line-height: 1.8; color: #231F20;">
                       Starting with lego robotics, I was limited to the parts avaialble and the physical limitations to what lego could do. Turning to the world of 3D modeling and CAD, through various softwares such as Fusion 360 and OnShape, I was able to create designs limited only by my imagination.
                    </p>
                    <p style="font-size: 1.1rem; line-height: 1.8; color: #231F20;">
                       Starting with designing simple things like pencil organizers and phone stands, I have now designed and 3D printed complex parts for rocketry and robotics projects.
                    </p>
                    <p style="font-size: 1.1rem; line-height: 1.8; color: #231F20;">
                        Since then I have expanded out to not only robotics and rocketry, but also photography equipment such as camera mounts and accessories., I have used my knowledge of CADing for biotech research. 
                    </p>
                </div>
            </div>

            <!-- Card from left -->
            <div class="info-card slide-left">
                <div style="flex: 1; min-width: 300px; padding: 2rem;">
                    <h3 style="color: #4F5D2F; font-size: 1.8rem; margin-bottom: 1rem;">Photography</h3>
                    <p style="font-size: 1.1rem; line-height: 1.8; color: #231F20;">
                        Ever since getting my first camera in middle school, I have loved capturing moments and scenes through photography. It's hard to describe what I have achieved in theese past years, but it has been more of a personal journey to capture what I see through my eyes. I have learned to capture the stars and nebula that arent visible to the human eyes through long exposure photography. I have also ventured into some videography to capture my projects.
                </div>
            </div>
        </div>
    </section>

    <style>
        .info-card {
            display: flex;
            gap: 2rem;
            align-items: center;
            flex-wrap: wrap;
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.6s ease, transform 0.6s ease;
        }

        .slide-left {
            transform: translateX(-100px);
        }

        .slide-right {
            transform: translateX(100px);
        }

        .info-card.visible {
            opacity: 1;
            transform: translateX(0);
        }
    </style>

    <script>
        const canvas = document.getElementById('particle-canvas');
        const ctx = canvas.getContext('2d');
        const heroTitle = document.getElementById('hero-title');
        
        // Typewriter effect
        const titleText = "Hello, I'm Patrick Chou";
        let charIndex = 0;
        
        function typeWriter() {
            if (charIndex < titleText.length) {
                heroTitle.textContent += titleText.charAt(charIndex);
                charIndex++;
                setTimeout(typeWriter, 100); // Adjust speed here (milliseconds per character)
            }
        }
        
        // Start typewriter effect after a short delay
        setTimeout(typeWriter, 500);
        
        // Portrait reveal setup
        const portraitContainer = document.getElementById('portrait-container');
        const revealCanvas = document.getElementById('reveal-canvas');
        const revealCtx = revealCanvas.getContext('2d');
        
        // Load the reveal image
        const revealImg = new Image();
        revealImg.src = 'assets/SeniorPortrait.png';
        
        // Set canvas size to match container
        revealCanvas.width = 240;
        revealCanvas.height = 240;
        
        // Create an offscreen canvas for the mask
        const maskCanvas = document.createElement('canvas');
        maskCanvas.width = 240;
        maskCanvas.height = 240;
        const maskCtx = maskCanvas.getContext('2d');
        
        portraitContainer.addEventListener('mousemove', (e) => {
            const rect = portraitContainer.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Draw on the mask
            maskCtx.globalCompositeOperation = 'source-over';
            maskCtx.fillStyle = 'white';
            maskCtx.beginPath();
            maskCtx.arc(x, y, 20, 0, Math.PI * 2);
            maskCtx.fill();
        });
        
        // Animation loop for portrait reveal
        function animateReveal() {
            // Clear the reveal canvas
            revealCtx.clearRect(0, 0, 240, 240);
            
            // Fade the mask back to 0 (transparent) over time
            maskCtx.globalCompositeOperation = 'destination-out';
            maskCtx.fillStyle = 'rgba(255, 255, 255, 0.02)';
            maskCtx.fillRect(0, 0, 240, 240);
            
            // Reset composite operation for next frame
            maskCtx.globalCompositeOperation = 'source-over';
            
            // Draw the reveal image using the mask
            revealCtx.save();
            
            // Use the mask as a clipping region
            revealCtx.drawImage(maskCanvas, 0, 0);
            revealCtx.globalCompositeOperation = 'source-in';
            revealCtx.drawImage(revealImg, 0, 0, 240, 240);
            
            revealCtx.restore();
            
            requestAnimationFrame(animateReveal);
        }
        
        // Start animation when image loads
        revealImg.onload = () => {
            animateReveal();
        };
        
        // Set canvas size
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Get text bounding boxes
        function getTextBounds() {
            const titleRect = heroTitle.getBoundingClientRect();
            const heroRect = document.getElementById('hero').getBoundingClientRect();
            const portraitRect = portraitContainer.getBoundingClientRect();
            
            return [
                {
                    x: titleRect.left - heroRect.left,
                    y: titleRect.top - heroRect.top,
                    width: titleRect.width,
                    height: titleRect.height
                },
                {
                    x: portraitRect.left - heroRect.left,
                    y: portraitRect.top - heroRect.top,
                    width: portraitRect.width,
                    height: portraitRect.height
                }
            ];
        }

        // Capsule collision detection helper
        function capsuleDistance(x1, y1, w1, h1, x2, y2, w2, h2) {
            const r1 = h1 / 2;
            const r2 = h2 / 2;
            
            const dx = x2 - x1;
            const dy = y2 - y1;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            const minDist = r1 + r2;
            
            return { distance, minDist, dx, dy };
        }

        // Capsule-to-rectangle collision
        function capsuleRectCollision(cx, cy, width, height, rx, ry, rw, rh) {
            const radius = height / 2;
            const expandedRect = {
                x: rx - radius,
                y: ry - radius,
                width: rw + radius * 2,
                height: rh + radius * 2
            };
            
            const closestX = Math.max(expandedRect.x, Math.min(cx, expandedRect.x + expandedRect.width));
            const closestY = Math.max(expandedRect.y, Math.min(cy, expandedRect.y + expandedRect.height));
            
            const dx = cx - closestX;
            const dy = cy - closestY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            return { collision: distance < radius, distance, dx, dy, radius };
        }

        // Particle class
        class Particle {
            constructor(index, label) {
                this.index = index;
                this.label = label;
                this.button = document.getElementById(`particle-${index}`);
                this.isHovered = false;
                this.savedVx = 0;
                this.savedVy = 0;
                
                let isValidPosition = false;
                
                setTimeout(() => {
                    this.width = this.button.offsetWidth;
                    this.height = this.button.offsetHeight;
                }, 0);
                
                while (!isValidPosition) {
                    this.x = Math.random() * (canvas.width - 200) + 100;
                    this.y = Math.random() * (canvas.height - 100) + 50;

                    const textBounds = getTextBounds();
                    isValidPosition = textBounds.every(box => {
                        const closestX = Math.max(box.x, Math.min(this.x, box.x + box.width));
                        const closestY = Math.max(box.y, Math.min(this.y, box.y + box.height));
                        const dx = this.x - closestX;
                        const dy = this.y - closestY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance >= 80;
                    });
                }
                
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.color = '#BB4430';
                
                setTimeout(() => {
                    this.width = this.button.offsetWidth;
                    this.height = this.button.offsetHeight;
                    this.updateButtonPosition();
                }, 10);
                
                this.button.addEventListener('mouseenter', () => {
                    this.isHovered = true;
                    this.savedVx = this.vx;
                    this.savedVy = this.vy;
                    this.vx = 0;
                    this.vy = 0;
                });
                
                this.button.addEventListener('mouseleave', () => {
                    this.isHovered = false;
                    this.vx = this.savedVx;
                    this.vy = this.savedVy;
                });
            }

            updateButtonPosition() {
                if (!this.width || !this.height) return;
                this.button.style.left = `${this.x - this.width / 2}px`;
                this.button.style.top = `${this.y - this.height / 2}px`;
            }

            update(particles, textBounds) {
                if (!this.width || !this.height) return;
                
                if (!this.isHovered) {
                    this.x += this.vx;
                    this.y += this.vy;

                    const radius = this.height / 2;
                    const halfWidth = this.width / 2;
                    
                    if (this.x + halfWidth > canvas.width || this.x - halfWidth < 0) {
                        this.vx = -this.vx;
                        this.savedVx = this.vx;
                        this.x = Math.max(halfWidth, Math.min(canvas.width - halfWidth, this.x));
                    }
                    if (this.y + radius > canvas.height || this.y - radius < 0) {
                        this.vy = -this.vy;
                        this.savedVy = this.vy;
                        this.y = Math.max(radius, Math.min(canvas.height - radius, this.y));
                    }

                    particles.forEach(other => {
                        if (other === this || !other.width || !other.height) return;
                        
                        const result = capsuleDistance(
                            this.x, this.y, this.width, this.height,
                            other.x, other.y, other.width, other.height
                        );
                        
                        if (result.distance < result.minDist) {
                            const angle = Math.atan2(result.dy, result.dx);
                            const overlap = result.minDist - result.distance;
                            
                            if (!this.isHovered) {
                                this.x -= Math.cos(angle) * overlap / 2;
                                this.y -= Math.sin(angle) * overlap / 2;
                            }
                            if (!other.isHovered) {
                                other.x += Math.cos(angle) * overlap / 2;
                                other.y += Math.sin(angle) * overlap / 2;
                            }
                            
                            if (!this.isHovered && !other.isHovered) {
                                const tempVx = this.vx;
                                const tempVy = this.vy;
                                this.vx = other.vx;
                                this.vy = other.vy;
                                other.vx = tempVx;
                                other.vy = tempVy;
                                
                                this.savedVx = this.vx;
                                this.savedVy = this.vy;
                                other.savedVx = other.vx;
                                other.savedVy = other.vy;
                            } else if (!this.isHovered) {
                                this.vx = -this.vx;
                                this.vy = -this.vy;
                                this.savedVx = this.vx;
                                this.savedVy = this.vy;
                            } else if (!other.isHovered) {
                                other.vx = -other.vx;
                                other.vy = -other.vy;
                                other.savedVx = other.vx;
                                other.savedVy = other.vy;
                            }
                        }
                    });

                    textBounds.forEach(box => {
                        const result = capsuleRectCollision(
                            this.x, this.y, this.width, this.height,
                            box.x, box.y, box.width, box.height
                        );
                        
                        if (result.collision) {
                            if (result.distance === 0) {
                                this.vx = -this.vx;
                                this.vy = -this.vy;
                                this.x += (Math.random() - 0.5) * 20;
                                this.y += (Math.random() - 0.5) * 20;
                                this.savedVx = this.vx;
                                this.savedVy = this.vy;
                            } else {
                                const nx = result.dx / result.distance;
                                const ny = result.dy / result.distance;
                                
                                const overlap = result.radius - result.distance;
                                this.x += nx * overlap;
                                this.y += ny * overlap;
                                
                                const dotProduct = this.vx * nx + this.vy * ny;
                                this.vx -= 2 * dotProduct * nx;
                                this.vy -= 2 * dotProduct * ny;
                                this.savedVx = this.vx;
                                this.savedVy = this.vy;
                            }
                        }
                    });
                }

                this.updateButtonPosition();
            }
        }

        // Create particles with labels
        const labels = ['Photography', 'Rocketry', 'Robotics', 'Projects'];
        const particles = [];
        for (let i = 0; i < 4; i++) {
            particles.push(new Particle(i, labels[i]));
        }

        // Animation loop
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const textBounds = getTextBounds();
            
            particles.forEach(particle => {
                particle.update(particles, textBounds);
            });

            requestAnimationFrame(animate);
        }

        animate();

        // Scroll animation for cards
        const observerOptions = {
            threshold: 0.2,
            rootMargin: '0px 0px -100px 0px'
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('visible');
                }
            });
        }, observerOptions);

        // Observe all info cards
        document.querySelectorAll('.info-card').forEach(card => {
            observer.observe(card);
        });

        // Add click handlers
        document.querySelectorAll('.particle-button').forEach((button, index) => {
            button.addEventListener('click', () => {
                alert(`You clicked ${labels[index]}!`);
            });
        });
    </script>
</body>
</html>